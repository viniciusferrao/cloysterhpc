/*
 * Copyright 2023 Vinícius Ferrão <vinicius@ferrao.net.br>
 * SPDX-License-Identifier: Apache-2.0
 */

#include <algorithm>
#include <filesystem>

#include <fmt/format.h>
#include <SimpleIni.h>

#include <cloysterhpc/inifile.h>

struct inifile::Impl {
    CSimpleIniA ini;
};

void inifile::loadData(const std::string& data) { m_impl->ini.LoadData(data); }

// TODO: Template<T> the next three functions
void inifile::loadFile(const std::string& filepath)
{
    m_impl->ini.LoadFile(filepath.c_str());
}

void inifile::loadFile(std::string_view filepath)
{
    m_impl->ini.LoadFile(filepath.data());
}

void inifile::loadFile(const std::filesystem::path& filepath)
{
    SI_Error result = m_impl->ini.LoadFile(filepath.c_str());
    if (result < 0) {
        throw std::runtime_error(
            fmt::format(R"(File "{}" could not be open, error {} )",
                filepath.c_str(), result));
    }
}

std::string inifile::getValue(const std::string& section,
    const std::string& key, const bool optional, const bool canBeNull)
{
    if (!optional && !exists(section, key))
        throw std::runtime_error(
            fmt::format(R"(Answerfile section "{}" must have "{}" key filled)",
                section, key));

    std::string value = m_impl->ini.GetValue(section.c_str(), key.c_str(), "");

    if (!canBeNull && value.empty())
        throw std::runtime_error(fmt::format(
            R"(Answerfile section "{}" key "{}" can't be null)", section, key));

    return value;
}

inifile::inifile() { m_impl->ini.SetUnicode(); }

inifile::inifile(const std::string& file)
{
    m_impl->ini.SetUnicode();
    loadData(file);
}

inifile inifile::mergeInto(const std::filesystem::path& other)
{
    inifile otherfile(other);

    for (const auto& sec : this->listAllSections()) {
        for (const auto& entry : this->listAllEntries(sec)) {
            const auto thisval = this->getValue(sec, entry);
            otherfile.setValue(sec, entry, thisval);
        }
    }

    /* Since the CSimpleIniA class we encapsulate, for some reason, does not
     * have a copy constructor, we need to save the object into a string
     * (that can be copied somewhat) and recreate the object before returning
     */
    std::string data;
    otherfile.save(data);

    return inifile { data };
}

void inifile::setValue(const std::string& section, const std::string& key,
    const std::string& newValue)
{
    m_impl->ini.SetValue(section.c_str(), key.c_str(), newValue.c_str());
}

bool inifile::deleteValue(const std::string& section, const std::string& key)
{
    return m_impl->ini.Delete(section.c_str(), key.c_str());
}

// Saves inifile data in a std::string
void inifile::save(std::string& holder) const { m_impl->ini.Save(holder); }

void inifile::saveFile(const std::string& filepath)
{
    m_impl->ini.SaveFile(filepath.c_str());
}

void inifile::saveFile(std::string_view filepath)
{
    m_impl->ini.SaveFile(filepath.data());
}

void inifile::saveFile(const std::filesystem::path& filepath)
{
    m_impl->ini.SaveFile(filepath.c_str());
}

// BUG: Returning a pointer is not a good idea, it causes ownership issues.
bool inifile::exists(const std::string& section, const std::string& key)
{
    return m_impl->ini.KeyExists(section.c_str(), key.c_str());
}

// BUG: Returning a pointer is not a good idea, it causes ownership issues.
bool inifile::exists(const std::string& section)
{
    return m_impl->ini.SectionExists(section.c_str());
}

static std::vector<std::string> convertIniNames(
    CSimpleIniA::TNamesDepend&& names)
{
    std::vector<std::string> ret;

    std::transform(names.begin(), names.end(), std::back_inserter(ret),
        [](auto entry) { return std::string { entry.pItem }; });

    return ret;
}

std::vector<std::string> inifile::listAllSections() const
{
    CSimpleIniA::TNamesDepend sections;
    m_impl->ini.GetAllSections(sections);

    return convertIniNames(std::move(sections));
}

/**
 * @brief List all the entries of a section, with a certain prefix, like
 * "node." for nodes
 *
 * @return The names of the entries found
 */
std::vector<std::string> inifile::listAllPrefixedEntries(
    const std::string_view prefix) const
{
    auto vec = listAllSections();
    std::vector<std::string> filtered;

    std::copy_if(vec.begin(), vec.end(), std::back_inserter(filtered),
        [prefix](std::string v) { return v.starts_with(prefix); });

    return filtered;
}

std::vector<std::string> inifile::listAllEntries(
    const std::string& section) const
{
    CSimpleIniA::TNamesDepend keys;
    m_impl->ini.GetAllKeys(section.c_str(), keys);

    return convertIniNames(std::move(keys));
}
